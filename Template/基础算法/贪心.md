#### 常见证明方法

##### 微扰（邻值交换）

##### 范围缩放

##### 决策包容性

##### 反证法

##### 数学归纳法

#### 区间问题

##### 区间合并

**问题：** 给定$n$个区间，合并所有有交集的区间，点重合也算有交集，求合并后的区间个数

**策略：** 

1. 对所有区间排序以`pair`的默认方式排序
2. 维护$[l,r]$，初始时两者均为负无穷
3. 遍历所有区间，若区间左端点大于$r$，计数，将$[l,r]$更新为当前区间，否则$r$和当前区间右端点取最大值

**代码：** 

```c++
sort(seg.begin(), seg.end());

int res = 0;
int l = -INF, r = -INF;
for (int i = 0; i < n; i ++ ){
    if (seg[i].first > r)
    {
        res ++ ;
        l = seg[i].first;
        r = seg[i].second;
    }
    else r = max(r, seg[i].second);
}
printf("%d\n", res);
```

##### 线段重叠问题

**问题：** 在多个线段中计算最长的重叠区间

**策略：** 

1. 按左端点从小到大、右端点从大到小排序
2. 维护一个区间$[l,r]$，初始二者为负无穷
3. 对于每个区间，若当前区间的右端点大于$r$，将$res$与$[l,r]$和当前区间重叠部分取最大值，并把$[l,r]$更新为当前区间，否则$res$与当前区间的长度取最大值，不必更新$[l,r]$ 

**代码：** 

```c++
int res = -INF;
int l = -INF, r = -INF;
for (int i = 0; i < n; i ++ )
    if (a[i].S > r)
    {
        res = max(res, r - a[i].F);
        l = a[i].F, r = a[i].S;
    }
	else res = max(res, a[i].S - a[i].F);
printf("%d\n", res);
```

##### 区间部分覆盖

**问题：** 数轴上有$n$个闭区间$[a_i,b_i]$，选择尽量少的区间覆盖一条指定的线段$[s,t]$ 

**策略：** 

1. 忽略所有和$[s,t]$没有交集的区间
2. 对所有区间以`pair`默认方式排序，维护一个$pos$，初始为$s$ 
3. 遍历所有区间，在左端点在$pos$之前的所有区间中，选择右端点最大的一个区间，计数，并将$pos$更新为这个区间的右端点
4. 当$pos\geq t$，就找到答案了，若当前没有区间的左端点在$pos$之前，或者遍历了所有区间$pos$仍然小于$t$，说明无解



##### 区间完全覆盖（不是很完善）

**问题：** 给定一个长度$m$，再给出若干个闭区间，求最少使用多少个闭区间可以将$m$完全覆盖

**策略：** 

1. 对所有区间以`pair`默认方式排序，维护一个$pos$，初始为第一个区间的右端点
2. 遍历所有区间，在所有左端点小于等于$pos$的区间中，选择右端点最大的，直到完全覆盖$m$ 



##### 选择最多不相交区间

**问题：** $n$个开区间$(a_i,b_i)$，选择尽量多个区间，使得这些区间两两不相交（一定要注意是左闭右开区间，注意看代码里的条件。）

**策略：** 

1. 按右端点从小到大、左端点从大到小排序
2. 从左到右遇到不相交的区间就选

**代码：** 

```c++
int res = 0, pos = -INF;
for (int i = 0; i < n; i ++ )
	if (a[i].F >= pos)
    {  // 注意条件下一个问题的区别
        res ++ ;
        pos = a[i].S;
    }
```

##### 区间选点

**问题：** 数轴上有$n$个闭区间$[A_i,B_i]$，取尽量少的点，使得每个区间都至少有一个点（如果是开区间的话，将右端点减少$1$再用这个模板即可）

**策略：** 

1. 按右端点从小到大、左端点从大到小排序
2. 维护一个$pos$为当前选定的最后一个点，初始为负无穷
3. 遍历所有区间，若当前区间左端点大于$pos$，则增加一个点，并令$pos$为当前区间的右端点

**代码：** 

```c++
int res = 0, pos = -INF;
for (int i = 0; i < n; i ++ )
	if (a[i].F > pos)
    {  // 注意条件上一个问题的区别
        res ++ ;
        pos = a[i].S;
    }
printf("%d\n", res);
```

##### 最大连续子序和（不限制长度）

**问题：** 在一个序列中求最大的连续子序和

**策略：** 转化为前缀和相减的形式，从前往后遍历，记录当前前缀和左侧最小的前缀和

**代码：** 

```c++
int res = -INF, mina = sum[0];
for (int i = L; i <= n; i ++ )
{
    res = max(res, sum[i] - mina);
    mina = min(mina, sum[i]);
}
printf("%d\n", res);
```

##### 最大连续子序和（限定最小长度）

**问题：** 在一个序列中求长度不小于$L$的最大连续子序和

**策略：** 

转化为前缀和相减的形式，从前往后遍历，记录当前前缀和左侧距离超过$L$的最小前缀和

**代码：** 

```c++
int res = -INF, mina = INF;
for (int i = L; i <= n; i ++ )
{
    mina = min(mina, sum[i - L]);
    res = max(res, sum[i] - mina);
}
printf("%d\n", res);
```

##### 最大连续子序和（限定最大长度）

**问题：** 在一个序列中求长度不超过$M$的连续子序列

**策略：** 其实这个并不是贪心，而是单调队列的应用

**代码：** 

```c++
int tt = -1, hh = 0;  // 队列
q[ ++ tt] = 0;
for (int i = 1; i <= n; i ++ )
{
    while (hh <= tt && q[hh] < i - m) hh ++ ;
    res = max(res, sum[i] - sum[q[hh]]);
    while (hh <= tt && sum[q[tt]] >= sum[i]) tt -- ;
    q[ ++ tt] = i;
}
printf("%d\n", res);
```

